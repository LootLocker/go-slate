// Code generated by go-imbed. DO NOT EDIT.

// Package slate holds binary resources embedded into Go executable
package slate

import (
	"os"
	"io"
	"bytes"
	"path/filepath"
	"sort"
	"path"
	"compress/gzip"
	"io/ioutil"
	"time"
)

func blob_bytes(uint32) []byte
func blob_string(uint32) string

// Asset represents binary resource stored within Go executable. Asset implements
// fmt.Stringer and io.WriterTo interfaces, decompressing binary data if necessary.
type Asset struct {
	name         string // File name
	size         int32  // File size (uncompressed)
	blob         []byte // Resource blob []byte
	str_blob     string // Resource blob as string
	isCompressed bool   // true if resources was compressed with gzip
	mime         string // MIME Type
	tag          string // Tag is essentially a Tag of resource content and can be used as a value for "Etag" HTTP header
}

// Name returns the base name of the asset
func (a *Asset) Name() string       { return a.name }
// MimeType returns MIME Type of the asset
func (a *Asset) MimeType() string   { return a.mime }
// IsCompressed returns true of asset has been compressed
func (a *Asset) IsCompressed() bool { return a.isCompressed }
// String returns (uncompressed, if necessary) content of asset as a string
func (a *Asset) String() string {
	if a.isCompressed {
		ungzip, _ := gzip.NewReader(bytes.NewReader(a.blob))
		ret, _ := ioutil.ReadAll(ungzip)
		ungzip.Close()
		return string(ret)
	}
	return a.str_blob
}

// Bytes returns (uncompressed) content of asset as a []byte
func (a *Asset) Bytes() []byte {
	if a.isCompressed {
		ungzip, _ := gzip.NewReader(bytes.NewReader(a.blob))
		ret, _ := ioutil.ReadAll(ungzip)
		ungzip.Close()
		return ret
	}
	ret := make([]byte, len(a.blob))
	copy(ret, a.blob)
	return ret
}

// Size implements os.FileInfo and returns the size of the asset (uncompressed, if asset has been compressed)
func (a *Asset) Size() int64        { return int64(a.size) }
// Mode implements os.FileInfo and always returns 0444
func (a *Asset) Mode() os.FileMode  { return 0444 }
// ModTime implements os.FileInfo and returns the time stamp when this package has been produced (the same value for all the assets)
func (a *Asset) ModTime() time.Time { return stamp }
// IsDir implements os.FileInfo and returns false
func (a *Asset) IsDir() bool        { return false }
// Sys implements os.FileInfo and returns nil
func (a *Asset) Sys() interface{}   { return a }

// WriteTo implements io.WriterTo interface and writes content of the asset to w
func (a *Asset) WriteTo(w io.Writer) (int64, error) {
	if a.isCompressed {
		ungzip, _ := gzip.NewReader(bytes.NewReader(a.blob))
		n, err := io.Copy(w, ungzip)
		ungzip.Close()
		return n, err
	}
	n, err := w.Write(a.blob)
	return int64(n), err
}

type assetReader struct {
	bytes.Reader
}

func (r *assetReader) Close() error {
	r.Reset(nil)
	return nil
}

// Returns content of the asset as io.ReaderCloser.
func (a *Asset) Reader() io.ReadCloser {
	if a.isCompressed {
		ungzip, _ := gzip.NewReader(bytes.NewReader(a.blob))
		return ungzip
	} else {
		ret := &assetReader{}
		ret.Reset(a.blob)
		return ret
	}
}

func cleanPath(path string) string {
	path = filepath.Clean(path)
	if filepath.IsAbs(path) {
		path = path[len(filepath.VolumeName(path)):]
		if len(path) > 0 || os.IsPathSeparator(path[0]) {
			path = path[1:]
		}
	} else if path == "." {
		return ""
	}
	return filepath.ToSlash(path)
}

// Opens asset as an io.ReadCloser. Returns os.ErrNotExist if no asset is found.
func Open(name string) (File, error) {
	return FS().Open(name)
}

// Gets asset by name. Returns nil if no asset found.
func Get(name string) *Asset {
	if entry, ok := fidx[name]; ok {
		return entry
	} else {
		return nil
	}
}

// Get asset by name. Panics if no asset found.
func Must(name string) *Asset {
	if entry, ok := fidx[name]; ok {
		return entry
	} else {
		panic("asset " + name + " not found")
	}
}

type directoryAsset struct {
	name  string
	dirs  []directoryAsset
	files []Asset
}

var root *directoryAsset

// A simple FileSystem abstraction
type FileSystem interface {
	Open(name string) (File, error)
	Stat(name string) (os.FileInfo, error)
	// As in filepath.Walk
	Walk(root string, walkFunc filepath.WalkFunc) error
}

// The CopyTo method extracts all mentioned files
// to a specified location, keeping directory structure.
// If supplied file is a directory, than it will be extracted
// recursively. CopyTo with no file mentioned will extract
// the whole content of the embedded filesystem.
// CopyTo returns error if there is a file with the same name
// at the target location, unless overwrite is set to true, or
// file has the same size and modification file as the extracted
// file.
// slate.CopyTo(".", mode, false) will effectively
// extract content of the filesystem to the current directory (which
// makes it the most space-wise inefficient self-extracting archive
// ever).
func CopyTo(target string, mode os.FileMode, overwrite bool, files ...string) error {
	mode    =  mode&0777
	dirmode := os.ModeDir|((mode&0444)>>2)|mode
	if len(files) == 0 {
		files = []string{""}
	}
	for _, file := range files {
		file = cleanPath(file)
		err := FS().Walk(file, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			targetPath := filepath.Join(target, path)
			fi, err := os.Stat(targetPath)
			if err == nil {
				if info.IsDir() && fi.IsDir() {
					return nil
				} else if info.IsDir() != fi.IsDir() {
					return os.ErrExist
				} else if !overwrite {
					if info.Size() == fi.Size() && info.ModTime().Equal(fi.ModTime()) {
						return nil
					} else {
						return os.ErrExist
					}
				}
			}
			if info.IsDir() {
				return os.MkdirAll(targetPath, dirmode)
			}
			asset := Get(path)
			if asset == nil {
				return os.ErrNotExist
			}
			targetPathDir := filepath.Dir(targetPath)
			if err = os.MkdirAll(targetPathDir, dirmode); err != nil {
				return err
			}
			dst, err := ioutil.TempFile(targetPathDir, ".imbed")
			if err != nil {
				return err
			}
			defer func() {
				dst.Close()
				os.Remove(dst.Name())
			}()
			_, err = asset.WriteTo(dst)
			if err != nil {
				return err
			}
			dst.Close()
			os.Chtimes(dst.Name(), info.ModTime(), info.ModTime())
			os.Chmod(dst.Name(), mode)
			return os.Rename(dst.Name(), targetPath)
		})
		if err != nil {
			return err
		}
	}
	return nil
}

type fileInfoSlice []os.FileInfo
func (fis *fileInfoSlice) Len() int           { return len(*fis) }
func (fis *fileInfoSlice) Less(i, j int) bool { return (*fis)[i].Name() < (*fis)[j].Name() }
func (fis *fileInfoSlice) Swap(i, j int) {
	s := (*fis)[i]
	(*fis)[i] = (*fis)[j]
	(*fis)[j] = s
}

func walkRec(fs FileSystem, info os.FileInfo, p string, walkFn filepath.WalkFunc) error {
	var (
		dir File
		fis fileInfoSlice
		err error
	)
	err = walkFn(p, info, nil)
	if err != nil {
		if info.IsDir() && err == filepath.SkipDir {
			return nil
		}
		return err
	}
	if !info.IsDir() {
		return nil
	}
	dir, err = fs.Open(p)
	if err != nil {
		return walkFn(p, info, err)
	}
	fis, err = dir.Readdir(-1)
	if err != nil {
		return walkFn(p, info, err)
	}
	sort.Sort(&fis)
	for i := range fis {
		fn := path.Join(p, fis[i].Name())
		err = walkRec(fs, fis[i], fn, walkFn)
		if err != nil {
			if !fis[i].IsDir() || err != filepath.SkipDir {
				return err
			}
		}
	}
	return nil
}

func walk(fs FileSystem, name string, walkFunc filepath.WalkFunc) error {
	var r os.FileInfo
	var err error
	name = cleanPath(name)
	r, err = fs.Stat(name)
	if err != nil {
		return err
	}
	return walkRec(fs, r, name, walkFunc)
}

type assetFs struct{}

// Returns embedded FileSystem
func FS() FileSystem {
	return &assetFs{}
}

func (fs *assetFs) Walk(root string, walkFunc filepath.WalkFunc) error {
	return walk(fs, root, walkFunc)
}

func (fs *assetFs) Stat(name string) (os.FileInfo, error) {
	name = cleanPath(name)
	if name == "" {
		return root, nil
	}
	if dir, ok := didx[name]; ok {
		return dir, nil
	}
	if asset, ok := fidx[name]; ok {
		return asset, nil
	}
	return nil, os.ErrNotExist
}

func (fs *assetFs) Open(name string) (File, error) {
	name = cleanPath(name)
	if name == "" {
		return root.open(""), nil
	}
	if dir, ok := didx[name]; ok {
		return dir.open(name), nil
	}
	if asset, ok := fidx[name]; ok {
		return asset.open(name), nil
	}
	return nil, os.ErrNotExist
}


// A File is returned by virtual FileSystem's Open method.
// The methods should behave the same as those on an *os.File.
type File interface {
	io.Closer
	io.Reader
	io.Seeker
	Readdir(count int) ([]os.FileInfo, error)
	Stat() (os.FileInfo, error)
}

func (a *Asset) open(name string) File {
	if a.isCompressed {
		ret := &assetCompressedFile{
			asset: a,
			name:  name,
		}
		ret.Reset(bytes.NewReader(a.blob))
		return ret
	} else {
		ret := &assetFile{
			asset: a,
			name:  name,
		}
		ret.Reset(a.blob)
		return ret
	}
}

func (d *directoryAsset) open(name string) File {
	return &directoryAssetFile{
		dir:  d,
		name: name,
		pos:  0,
	}
}

type directoryAssetFile struct {
	dir  *directoryAsset
	name string
	pos  int
}

func (d *directoryAssetFile) Name() string {
	return d.name
}

func (d *directoryAssetFile) checkClosed() error {
	if d.pos < 0 {
		return os.ErrClosed
	}
	return nil
}

func (d *directoryAssetFile) Close() error {
	if err := d.checkClosed(); err != nil {
		return err
	}
	d.pos = -1
	return nil
}

func (d *directoryAssetFile) Read([]byte) (int, error) {
	if err := d.checkClosed(); err != nil {
		return 0, err
	}
	return 0, io.EOF
}

func (d *directoryAssetFile) Stat() (os.FileInfo, error) {
	if err := d.checkClosed(); err != nil {
		return nil, err
	}
	return d.dir, nil
}

func (d *directoryAssetFile) Seek(pos int64, whence int) (int64, error) {
	if err := d.checkClosed(); err != nil {
		return 0, err
	}
	return 0, os.ErrInvalid
}

func (d *directoryAssetFile) Readdir(count int) ([]os.FileInfo, error) {
	if err := d.checkClosed(); err != nil {
		return nil, err
	}
	var (
		last int
		total = len(d.dir.dirs) + len(d.dir.files)
	)
	if d.pos > total {
		if count > 0 {
			return nil, io.EOF
		} else {
			return nil, nil
		}
	}
	if count <= 0 || (d.pos + count) <= total {
		last = total
	} else {
		last = d.pos + count
	}
	ret := make([]os.FileInfo, 0, last - d.pos)
	if d.pos < len(d.dir.dirs) {
		var stop int
		if last > len(d.dir.dirs) {
			stop = len(d.dir.dirs)
		} else {
			stop = last
		}
		for i := d.pos; i < stop; i++ {
			ret = append(ret, &d.dir.dirs[i])
		}
		d.pos = stop
	}
	var start, stop int
	start = d.pos - len(d.dir.dirs)
	stop = last - len(d.dir.dirs)
	for i := start; i < stop; i++ {
		ret = append(ret, &d.dir.files[i])
	}
	d.pos = last
	return ret, nil
}

func (d *directoryAsset) Name() string       { return d.name }
func (d *directoryAsset) Size() int64        { return 0 }
func (d *directoryAsset) Mode() os.FileMode  { return os.ModeDir | 0555 }
func (d *directoryAsset) ModTime() time.Time { return stamp }
func (d *directoryAsset) IsDir() bool        { return true }
func (d *directoryAsset) Sys() interface{}   { return d }

type assetFile struct {
	assetReader
	name string
	asset *Asset
}

func (a *assetFile) Name() string {
	return a.name
}

func (a *assetFile) Stat() (os.FileInfo, error) {
	return a.asset, nil
}

func (a *assetFile) Readdir(int) ([]os.FileInfo, error) {
	return nil, os.ErrInvalid
}
type assetCompressedFile struct {
	gzip.Reader
	name  string
	asset *Asset
}

func (a *assetCompressedFile) Name() string {
	return a.name
}

func (a *assetCompressedFile) Stat() (os.FileInfo, error) {
	return a.asset, nil
}

func (a *assetCompressedFile) Seek(int64, int) (int64, error) {
	return 0, os.ErrInvalid
}

func (a *assetCompressedFile) Readdir(count int) ([]os.FileInfo, error) {
	return nil, os.ErrInvalid
}

type unionFs struct {
	root string
}

func NewUnionFS(src string) (FileSystem, error) {
	abs, err := filepath.Abs(src)
	if err != nil {
		return nil, err
	}
	return &unionFs{
		root: abs,
	}, nil
}

func (fs *unionFs) Stat(name string) (os.FileInfo, error) {
	name = cleanPath(name)
	fname := filepath.Join(fs.root, filepath.FromSlash(name))
	fi, err := os.Stat(fname)
	if err == nil {
		return fi, nil
	}
	return FS().Stat(name)
}

func (fs *unionFs) Open(name string) (File, error) {
	name = cleanPath(name)
	fname := filepath.Join(fs.root, filepath.FromSlash(name))
	fi, err := os.Stat(fname)
	if err == nil {
		file, err := os.OpenFile(fname, os.O_RDONLY, 0)
		if err == nil {
			if !fi.IsDir() {
				return &unionFsFile{
					name: name,
					file: file,
				}, nil
			} else {
				dir, _ := didx[name]
				return &unionFsDirectoryFile{
					name:  name,
					dir:   dir,
					fsDir: file,
					pos:   0,
				}, nil
			}
		}
	}
	return FS().Open(name)
}

func (fs *unionFs) Walk(root string, walkFunc filepath.WalkFunc) error {
	return walk(fs, root, walkFunc)
}

type unionFsFile struct {
	name string
	file *os.File
}

func (f *unionFsFile) Name() string { return f.name }
func (f *unionFsFile) Close() error { return f.file.Close() }
func (f *unionFsFile) Read(d []byte) (int, error) { return f.file.Read(d) }
func (f *unionFsFile) Stat() (os.FileInfo, error) { return f.file.Stat() }
func (f *unionFsFile) Seek(pos int64, whence int) (int64, error) { return f.file.Seek(pos, whence) }
func (f *unionFsFile) Readdir(count int) ([]os.FileInfo, error) { return f.file.Readdir(count) }

type unionFsDirectoryFile struct {
	name  string
	dir   *directoryAsset
	fsDir *os.File
	pos   int
}

func (d *unionFsDirectoryFile) Name() string { return d.name }
func (d *unionFsDirectoryFile) Close() error {
	if d.fsDir == nil {
		return os.ErrClosed
	}
	err := d.fsDir.Close()
	d.fsDir = nil
	return err
}

func (d *unionFsDirectoryFile) Read([]byte) (int, error) {
	if d.fsDir == nil {
		return 0, os.ErrClosed
	}
	return 0, io.EOF
}

func (d *unionFsDirectoryFile) Stat() (os.FileInfo, error) {
	if d.fsDir == nil {
		return nil, os.ErrClosed
	}
	return d.fsDir.Stat()
}

func (d *unionFsDirectoryFile) Seek(pos int64, whence int) (int64, error) {
	if d.fsDir == nil {
		return 0, os.ErrClosed
	}
	return 0, os.ErrInvalid
}
func (d *unionFsDirectoryFile) Readdir(count int) ([]os.FileInfo, error) {
	if d.fsDir == nil {
		return nil, os.ErrClosed
	}
	if d.pos < 0 {
		if count > 0 {
			return nil, io.EOF
		} else {
			return nil, nil
		}
	}
	if d.dir == nil {
		return d.fsDir.Readdir(count)
	}
	ret, err := d.fsDir.Readdir(count)
	if count > 0 && err == nil {
		return ret, err
	}
	embedded := make([]os.FileInfo, 0, len(d.dir.dirs) + len(d.dir.files))
	for i := range d.dir.dirs {
		embedded = append(embedded, &d.dir.dirs[i])
	}
	for i := range d.dir.files {
		embedded = append(embedded, &d.dir.files[i])
	}
	for _, fi := range embedded[d.pos:] {
		if count > 0 && len(ret) >= count {
			return ret, nil
		}
		d.pos++
		if _, err := os.Stat(filepath.Join(d.fsDir.Name(), fi.Name())); err == nil {
			continue
		}
		ret = append(ret, fi)
	}
	d.pos = -1
	return ret, nil
}

var fidx = make(map[string]*Asset)
var didx = make(map[string]*directoryAsset)
var stamp time.Time

func init() {
	stamp = time.Unix(1516044723, 537397000)
	bb := blob_bytes(179792)
	bs := blob_string(179792)
	root = &directoryAsset{
		dirs: []directoryAsset{
			{
				name: "fonts",
				files: []Asset{
					{
						name:         "slate.eot",
						blob:         bb[11296:13172],
						str_blob:     bs[11296:13172],
						mime:         "application/vnd.ms-fontobject",
						tag:          "2r7uuaqqmoiv4",
						size:         1876,
						isCompressed: false,
					},
					{
						name:         "slate.svg",
						blob:         bb[13176:14105],
						str_blob:     bs[13176:14105],
						mime:         "image/svg+xml",
						tag:          "gplxd3enqktrg",
						size:         2936,
						isCompressed: true,
					},
					{
						name:         "slate.ttf",
						blob:         bb[14112:15832],
						str_blob:     bs[14112:15832],
						mime:         "application/x-font-ttf",
						tag:          "cjghtr7siys7o",
						size:         1720,
						isCompressed: false,
					},
					{
						name:         "slate.woff",
						blob:         bb[15832:17628],
						str_blob:     bs[15832:17628],
						mime:         "application/font-woff",
						tag:          "li2hxyu6dv65w",
						size:         1796,
						isCompressed: false,
					},
					{
						name:         "slate.woff2",
						blob:         bb[17632:18428],
						str_blob:     bs[17632:18428],
						mime:         "application/binary",
						tag:          "ucope254cfna4",
						size:         796,
						isCompressed: false,
					},
				},
			},
			{
				name: "images",
				files: []Asset{
					{
						name:         "logo.png",
						blob:         bb[18432:40749],
						str_blob:     bs[18432:40749],
						mime:         "image/png",
						tag:          "yai3uqds5i2y6",
						size:         22317,
						isCompressed: false,
					},
					{
						name:         "navbar.png",
						blob:         bb[40752:40848],
						str_blob:     bs[40752:40848],
						mime:         "image/png",
						tag:          "hrzkfootpekwg",
						size:         96,
						isCompressed: false,
					},
				},
			},
			{
				name: "includes",
				files: []Asset{
					{
						name:         "_errors.md",
						blob:         bb[40848:41971],
						str_blob:     bs[40848:41971],
						mime:         "application/binary",
						tag:          "5f55ohkbyli5o",
						size:         1123,
						isCompressed: false,
					},
				},
			},
			{
				name: "javascripts",
				dirs: []directoryAsset{
					{
						name: "app",
						files: []Asset{
							{
								name:         "_lang.js",
								blob:         bb[46912:48757],
								str_blob:     bs[46912:48757],
								mime:         "application/javascript",
								tag:          "wfrqvnel6mft6",
								size:         4897,
								isCompressed: true,
							},
							{
								name:         "_search.js",
								blob:         bb[48760:49683],
								str_blob:     bs[48760:49683],
								mime:         "application/javascript",
								tag:          "tvsgfshjey3aq",
								size:         2396,
								isCompressed: true,
							},
							{
								name:         "_toc.js",
								blob:         bb[49688:50895],
								str_blob:     bs[49688:50895],
								mime:         "application/javascript",
								tag:          "4vxjzfn5vdqpk",
								size:         3528,
								isCompressed: true,
							},
						},
					},
					{
						name: "lib",
						files: []Asset{
							{
								name:         "_energize.js",
								blob:         bb[50896:53041],
								str_blob:     bs[50896:53041],
								mime:         "application/javascript",
								tag:          "4dgb3gjo2q5qo",
								size:         5455,
								isCompressed: true,
							},
							{
								name:         "_imagesloaded.min.js",
								blob:         bb[53048:55386],
								str_blob:     bs[53048:55386],
								mime:         "application/javascript",
								tag:          "bfj46g3p5l44g",
								size:         6949,
								isCompressed: true,
							},
							{
								name:         "_jquery.highlight.js",
								blob:         bb[55392:56835],
								str_blob:     bs[55392:56835],
								mime:         "application/javascript",
								tag:          "mhe3grcpsfjco",
								size:         3983,
								isCompressed: true,
							},
							{
								name:         "_jquery.js",
								blob:         bb[56840:134947],
								str_blob:     bs[56840:134947],
								mime:         "application/javascript",
								tag:          "aiaxf67l55a7e",
								size:         279271,
								isCompressed: true,
							},
							{
								name:         "_lunr.js",
								blob:         bb[134952:147166],
								str_blob:     bs[134952:147166],
								mime:         "application/javascript",
								tag:          "4nzt4yhfywnru",
								size:         52362,
								isCompressed: true,
							},
						},
					},
				},
				files: []Asset{
					{
						name:         "all.js",
						blob:         bb[46592:46651],
						str_blob:     bs[46592:46651],
						mime:         "application/javascript",
						tag:          "dp6vkvg62mdf4",
						size:         53,
						isCompressed: true,
					},
					{
						name:         "all_nosearch.js",
						blob:         bb[46656:46912],
						str_blob:     bs[46656:46912],
						mime:         "application/javascript",
						tag:          "yscp6kzazppu4",
						size:         387,
						isCompressed: true,
					},
				},
			},
			{
				name: "layouts",
				files: []Asset{
					{
						name:         "layout.tmpl",
						blob:         bb[147168:149286],
						str_blob:     bs[147168:149286],
						mime:         "application/binary",
						tag:          "gqa2hcaksx6vq",
						size:         2118,
						isCompressed: false,
					},
				},
			},
			{
				name: "stylesheets",
				files: []Asset{
					{
						name:         "_icon-font.scss",
						blob:         bb[149288:150085],
						str_blob:     bs[149288:150085],
						mime:         "application/binary",
						tag:          "flig32x2gxww6",
						size:         797,
						isCompressed: false,
					},
					{
						name:         "_normalize.scss",
						blob:         bb[150088:158014],
						str_blob:     bs[150088:158014],
						mime:         "application/binary",
						tag:          "7w7nsc2eik5dy",
						size:         7926,
						isCompressed: false,
					},
					{
						name:         "_rtl.scss",
						blob:         bb[158016:160944],
						str_blob:     bs[158016:160944],
						mime:         "application/binary",
						tag:          "7ruwsdsbygfls",
						size:         2928,
						isCompressed: false,
					},
					{
						name:         "_variables.scss",
						blob:         bb[160944:164737],
						str_blob:     bs[160944:164737],
						mime:         "application/binary",
						tag:          "wv2nchckgitqs",
						size:         3793,
						isCompressed: false,
					},
					{
						name:         "print.css.scss",
						blob:         bb[164744:167323],
						str_blob:     bs[164744:167323],
						mime:         "application/binary",
						tag:          "6cazyz5hdscfm",
						size:         2579,
						isCompressed: false,
					},
					{
						name:         "screen.css.scss",
						blob:         bb[167328:179785],
						str_blob:     bs[167328:179785],
						mime:         "application/binary",
						tag:          "pjh7rum2ujgh6",
						size:         12457,
						isCompressed: false,
					},
				},
			},
		},
		files: []Asset{
			{
				name:         "CHANGELOG.md",
				blob:         bb[0:3949],
				str_blob:     bs[0:3949],
				mime:         "application/binary",
				tag:          "4fqsrxc2h5qj6",
				size:         3949,
				isCompressed: false,
			},
			{
				name:         "LICENSE",
				blob:         bb[3952:4521],
				str_blob:     bs[3952:4521],
				mime:         "application/binary",
				tag:          "nknfjbqbkn6ay",
				size:         569,
				isCompressed: false,
			},
			{
				name:         "README.md",
				blob:         bb[4528:11290],
				str_blob:     bs[4528:11290],
				mime:         "application/binary",
				tag:          "xoh4gcvwl72qe",
				size:         6762,
				isCompressed: false,
			},
			{
				name:         "index.html.md",
				blob:         bb[41976:46589],
				str_blob:     bs[41976:46589],
				mime:         "application/binary",
				tag:          "zw7gs2r2frsms",
				size:         4613,
				isCompressed: false,
			},
		},
	}
	didx[""] = root
	didx["fonts"] = &root.dirs[0]
	fidx["fonts/slate.eot"] = &root.dirs[0].files[0]
	fidx["fonts/slate.svg"] = &root.dirs[0].files[1]
	fidx["fonts/slate.ttf"] = &root.dirs[0].files[2]
	fidx["fonts/slate.woff"] = &root.dirs[0].files[3]
	fidx["fonts/slate.woff2"] = &root.dirs[0].files[4]
	didx["images"] = &root.dirs[1]
	fidx["images/logo.png"] = &root.dirs[1].files[0]
	fidx["images/navbar.png"] = &root.dirs[1].files[1]
	didx["includes"] = &root.dirs[2]
	fidx["includes/_errors.md"] = &root.dirs[2].files[0]
	didx["javascripts"] = &root.dirs[3]
	didx["javascripts/app"] = &root.dirs[3].dirs[0]
	fidx["javascripts/app/_lang.js"] = &root.dirs[3].dirs[0].files[0]
	fidx["javascripts/app/_search.js"] = &root.dirs[3].dirs[0].files[1]
	fidx["javascripts/app/_toc.js"] = &root.dirs[3].dirs[0].files[2]
	didx["javascripts/lib"] = &root.dirs[3].dirs[1]
	fidx["javascripts/lib/_energize.js"] = &root.dirs[3].dirs[1].files[0]
	fidx["javascripts/lib/_imagesloaded.min.js"] = &root.dirs[3].dirs[1].files[1]
	fidx["javascripts/lib/_jquery.highlight.js"] = &root.dirs[3].dirs[1].files[2]
	fidx["javascripts/lib/_jquery.js"] = &root.dirs[3].dirs[1].files[3]
	fidx["javascripts/lib/_lunr.js"] = &root.dirs[3].dirs[1].files[4]
	fidx["javascripts/all.js"] = &root.dirs[3].files[0]
	fidx["javascripts/all_nosearch.js"] = &root.dirs[3].files[1]
	didx["layouts"] = &root.dirs[4]
	fidx["layouts/layout.tmpl"] = &root.dirs[4].files[0]
	didx["stylesheets"] = &root.dirs[5]
	fidx["stylesheets/_icon-font.scss"] = &root.dirs[5].files[0]
	fidx["stylesheets/_normalize.scss"] = &root.dirs[5].files[1]
	fidx["stylesheets/_rtl.scss"] = &root.dirs[5].files[2]
	fidx["stylesheets/_variables.scss"] = &root.dirs[5].files[3]
	fidx["stylesheets/print.css.scss"] = &root.dirs[5].files[4]
	fidx["stylesheets/screen.css.scss"] = &root.dirs[5].files[5]
	fidx["CHANGELOG.md"] = &root.files[0]
	fidx["LICENSE"] = &root.files[1]
	fidx["README.md"] = &root.files[2]
	fidx["index.html.md"] = &root.files[3]
}
